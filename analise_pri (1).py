# -*- coding: utf-8 -*-
"""Analise_PRI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/Pridefrancas/DATATHON-2DTAT/blob/main/Analise_PRI.ipynb
"""

import pandas as pd
from sqlalchemy import create_engine

def create_conn():
    # Defina os parâmetros de conexão
    db_user = 'magic-steps_owner'
    db_password = 'FGD4APlVcW0u'
    db_host = 'ep-curly-wave-a4dkdimo.us-east-1.aws.neon.tech'
    db_port = '5432'
    db_name = 'magic-steps'

    # Crie a URL de conexão
    connection_url = f'postgresql://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}'

    # Crie um engine do SQLAlchemy
    engine = create_engine(connection_url)
    return engine
engine = create_conn()

# Defina a consulta SQL para a view
query = 'SELECT * FROM magic_steps.inativos_full'

# Execute a consulta e carregue os resultados em um DataFrame
df_inativos_full = pd.read_sql(query, engine)

# Mostre as primeiras linhas do DataFrame
print(df_inativos_full.head())

import matplotlib.pyplot as plt
# Count the occurrences of each inactivation reason
reason_counts = df_inativos_full['motivoinativacao'].value_counts()

# Plot the distribution of inactivation reasons
plt.figure(figsize=(10, 6))
reason_counts.plot(kind='bar')
plt.title('Distribuição dos Motivos de Inativação')
plt.xlabel('Motivo de Inativação')
plt.ylabel('Número de Alunos')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# Calculate the average grade per discipline
average_grade_per_discipline = df_inativos_full.groupby('nomedisciplina')['notafase'].mean().sort_values(ascending=False)

# Plot the average grades per discipline
plt.figure(figsize=(10, 6))
average_grade_per_discipline.plot(kind='bar')
plt.title('Desempenho Médio por Disciplina')
plt.xlabel('Disciplina')
plt.ylabel('Nota Média')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# Display the average grades in a table
average_grade_per_discipline.reset_index(name='Nota Média')

"""#Motivos de inativação entre os alunos:

**Outras prioridades/trabalho:** Este é o motivo mais frequente para a inativação dos alunos. Isso sugere que muitos estudantes estão priorizando o trabalho ou outras atividades sobre seus estudos.

**Sem adaptação ao curso:** Outro motivo comum, indicando que alguns alunos podem não ter se ajustado bem ao curso ou à instituição.

**Desistência por motivos pessoais:** Reflete que questões pessoais são uma razão significativa para alguns alunos deixarem o curso.

**Problemas financeiros:** Também aparece com frequência, indicando que dificuldades econômicas têm um impacto considerável na continuidade dos estudos.

Este gráfico ajuda a entender melhor os desafios enfrentados pelos alunos e pode auxiliar na formulação de estratégias para reduzir as taxas de inativação, como suporte financeiro, aconselhamento acadêmico e ajustes curriculares.
"""

# Ler as tabelas do PostgreSQL para dataframes pandas
tbsituacaoalunoturma_m = pd.read_sql_table('tbsituacaoalunoturma_m', con=engine, schema='magic_steps')
tbalunoturma = pd.read_sql_table('tbalunoturma', con=engine, schema='magic_steps')

# Fazer o join entre os dataframes
merged_df = pd.merge(tbsituacaoalunoturma_m, tbalunoturma, left_on='IdSituacaoAlunoTurma', right_on='IdSituacaoAlunoTurma')

# Filtrar os dados conforme a condição especificada
filtered_df = merged_df[merged_df['SituacaoSistema'] != 'P']

# Converter a coluna de data para datetime e extrair o ano
filtered_df['DataSituacaoAtivo'] = pd.to_datetime(filtered_df['DataSituacaoAtivo'])
filtered_df['ano'] = filtered_df['DataSituacaoAtivo'].dt.year

# Agrupar pelos campos necessários e contar
grouped_df = filtered_df.groupby(['SituacaoAlunoTurma', 'ano']).size().reset_index(name='count')

# Ordenar por ano em ordem decrescente
result_df = grouped_df.sort_values(by='ano', ascending=False)

print(result_df)

import matplotlib.pyplot as plt

# Plotar a distribuição dos alunos por situação ao longo dos anos
plt.figure(figsize=(12, 8))
for situacao in result_df['SituacaoAlunoTurma'].unique():
    subset = result_df[result_df['SituacaoAlunoTurma'] == situacao]
    plt.plot(subset['ano'], subset['count'], label=situacao)

plt.xlabel('Ano')
plt.ylabel('Número de Alunos')
plt.title('Distribuição dos Alunos por Situação ao Longo dos Anos')
plt.legend()
plt.grid(True)
plt.show()

# Análise de tendências
pivot_df = result_df.pivot(index='ano', columns='SituacaoAlunoTurma', values='count')
pivot_df.plot(kind='bar', stacked=True, figsize=(12, 8))

plt.xlabel('Ano')
plt.ylabel('Número de Alunos')
plt.title('Tendências de Situação dos Alunos ao Longo dos Anos')
plt.legend(title='Situação do Aluno')
plt.xticks(rotation=45)
plt.grid(True)
plt.show()

# Comparação entre situações
plt.figure(figsize=(12, 8))
result_df.groupby('SituacaoAlunoTurma')['count'].sum().plot(kind='bar')

plt.xlabel('Situação do Aluno')
plt.ylabel('Total de Alunos')
plt.title('Comparação Entre Situações de Alunos')
plt.xticks(rotation=45)
plt.grid(True)
plt.show()

# Conectar ao banco de dados e ler as tabelas
engine = create_conn()
tbsituacaoalunoturma_m = pd.read_sql_table('tbsituacaoalunoturma_m', con=engine, schema='magic_steps')
tbalunoturma = pd.read_sql_table('tbalunoturma', con=engine, schema='magic_steps')

# Fazer o join entre os dataframes
merged_df = pd.merge(tbsituacaoalunoturma_m, tbalunoturma, left_on='IdSituacaoAlunoTurma', right_on='IdSituacaoAlunoTurma')

# Filtrar os dados conforme a condição especificada
filtered_df = merged_df[merged_df['SituacaoSistema'] != 'P']

# Converter a coluna de data para datetime e extrair o ano
filtered_df['DataSituacaoAtivo'] = pd.to_datetime(filtered_df['DataSituacaoAtivo'])
filtered_df['ano'] = filtered_df['DataSituacaoAtivo'].dt.year

# Filtrar apenas os "Desistentes"
desistentes_df = filtered_df[filtered_df['SituacaoAlunoTurma'] == 'Desistente']

# Agrupar pelos campos necessários e contar
grouped_df = desistentes_df.groupby(['SituacaoAlunoTurma', 'ano']).size().reset_index(name='count')

# Ordenar por ano em ordem decrescente
result_df = grouped_df.sort_values(by='ano', ascending=False)

# Mostrar os dados
print(result_df)

# Plotar a distribuição dos desistentes ao longo dos anos
plt.figure(figsize=(12, 8))
for situacao in result_df['SituacaoAlunoTurma'].unique():
    subset = result_df[result_df['SituacaoAlunoTurma'] == situacao]
    plt.plot(subset['ano'], subset['count'], label=situacao)

plt.xlabel('Ano')
plt.ylabel('Número de Alunos')
plt.title('Distribuição dos Desistentes ao Longo dos Anos')
plt.legend()
plt.grid(True)
plt.show()

# Análise de tendências
plt.figure(figsize=(12, 8))
pivot_df = result_df.pivot(index='ano', columns='SituacaoAlunoTurma', values='count')
pivot_df.plot(kind='bar', stacked=True)

plt.xlabel('Ano')
plt.ylabel('Número de Alunos')
plt.title('Tendências de Desistentes ao Longo dos Anos')
plt.legend(title='Situação do Aluno')
plt.grid(True)
plt.show()

# Comparação entre anos
plt.figure(figsize=(12, 8))
result_df.groupby('ano')['count'].sum().plot(kind='bar')

plt.xlabel('Ano')
plt.ylabel('Total de Desistentes')
plt.title('Comparação de Desistentes Entre os Anos')
plt.grid(True)
plt.show()

# Conectar ao banco de dados e ler as tabelas
engine = create_conn()
tbsituacaoalunoturma_m = pd.read_sql_table('tbsituacaoalunoturma_m', con=engine, schema='magic_steps')
tbalunoturma = pd.read_sql_table('tbalunoturma', con=engine, schema='magic_steps')

# Fazer o join entre os dataframes
merged_df = pd.merge(tbsituacaoalunoturma_m, tbalunoturma, left_on='IdSituacaoAlunoTurma', right_on='IdSituacaoAlunoTurma')

# Filtrar os dados conforme a condição especificada
filtered_df = merged_df[merged_df['SituacaoSistema'] != 'P']

# Converter a coluna de data para datetime e extrair o ano
filtered_df['DataSituacaoAtivo'] = pd.to_datetime(filtered_df['DataSituacaoAtivo'])
filtered_df['ano'] = filtered_df['DataSituacaoAtivo'].dt.year

# Filtrar apenas os "Desistentes"
desistentes_df = filtered_df[filtered_df['SituacaoAlunoTurma'] == 'Desistente']

# Agrupar pelos campos necessários e contar
grouped_df = desistentes_df.groupby(['SituacaoAlunoTurma', 'ano']).size().reset_index(name='count')

# Ordenar por ano em ordem decrescente
result_df = grouped_df.sort_values(by='ano', ascending=False)

# Mostrar os dados
print(result_df)

# Plotar a distribuição dos desistentes ao longo dos anos
plt.figure(figsize=(12, 8))
for situacao in result_df['SituacaoAlunoTurma'].unique():
    subset = result_df[result_df['SituacaoAlunoTurma'] == situacao]
    plt.plot(subset['ano'], subset['count'], label=situacao)

plt.xlabel('Ano')
plt.ylabel('Número de Alunos')
plt.title('Distribuição dos Desistentes ao Longo dos Anos')
plt.legend()
plt.grid(True)
plt.show()

# Análise de tendências
plt.figure(figsize=(12, 8))
pivot_df = result_df.pivot(index='ano', columns='SituacaoAlunoTurma', values='count')
pivot_df.plot(kind='bar', stacked=True)

plt.xlabel('Ano')
plt.ylabel('Número de Alunos')
plt.title('Tendências de Desistentes ao Longo dos Anos')
plt.legend(title='Situação do Aluno')
plt.grid(True)
plt.show()

# Comparação entre anos
plt.figure(figsize=(12, 8))
result_df.groupby('ano')['count'].sum().plot(kind='bar')

plt.xlabel('Ano')
plt.ylabel('Total de Desistentes')
plt.title('Comparação de Desistentes Entre os Anos')
plt.grid(True)
plt.show()

# Defina a consulta SQL para a view
query = 'SELECT * FROM magic_steps.vw_aluno_obs'

# Execute a consulta e carregue os resultados em um DataFrame
df = pd.read_sql(query, engine)

# Mostre as primeiras linhas do DataFrame
print(df.head())

# Process the data for gender and race distribution
gender_distribution = df['Sexo'].value_counts()
race_distribution = df['CorRaca'].value_counts()

# Process the data for reasons of inactivation
inactivation_reasons = df['MotivoInativacao'].value_counts()

# Plotting gender distribution
plt.figure(figsize=(10, 5))
gender_distribution.plot(kind='bar')
plt.title('Distribuição de Gênero dos Alunos')
plt.xlabel('Gênero')
plt.ylabel('Número de Alunos')
plt.xticks(rotation=0)
plt.show()

# Plotting race distribution
plt.figure(figsize=(10, 5))
race_distribution.plot(kind='bar')
plt.title('Distribuição de Cor/Raça dos Alunos')
plt.xlabel('Cor/Raça')
plt.ylabel('Número de Alunos')
plt.xticks(rotation=0)
plt.show()

# Plotting reasons for inactivation
plt.figure(figsize=(12, 6))
inactivation_reasons.plot(kind='bar')
plt.title('Motivos de Inativação dos Alunos')
plt.xlabel('Motivo de Inativação')
plt.ylabel('Número de Alunos')
plt.xticks(rotation=45, ha='right')
plt.show()

"""**Distribuição de Gênero:**

A distribuição de gênero entre os alunos parece ser equilibrada, com uma representação significativa tanto de alunos do sexo masculino quanto do sexo feminino.

**Distribuição de Cor/Raça: ** **negrito**

A maioria dos alunos se identifica com uma cor/raça específica (representada pelo código "B" no gráfico), o que pode indicar a predominância de um grupo racial na amostra.

**Motivos de Inativação:**

O motivo mais comum para a inativação dos alunos é "Falta de retorno às nossas tentativas de contato", seguido por "Conflito com horário escolar / período integral". Isso sugere que a comunicação e a compatibilidade de horários são áreas críticas que precisam de atenção.
"""

# Analyzing the student situations in classes
student_situations = df['IdSituacaoAlunoTurma'].value_counts()

# Map situation IDs to more descriptive labels if available
# Note: We don't have a mapping provided in the dataset, so we will work with the IDs for now.

# Plotting the distribution of student situations in classes
plt.figure(figsize=(10, 5))
student_situations.plot(kind='bar')
plt.title('Situações dos Alunos nas Turmas')
plt.xlabel('ID da Situação do Aluno na Turma')
plt.ylabel('Número de Alunos')
plt.xticks(rotation=0)
plt.show()

# Checking for any specific situation codes with the comments, if available
unique_situations_with_comments = df[['IdSituacaoAlunoTurma', 'ComentarioInativacao']].dropna().drop_duplicates()

unique_situations_with_comments.head()

"""Situações dos Alunos nas Turmas
A análise das situações dos alunos nas turmas revela o seguinte:

Distribuição das Situações:

A maioria dos alunos está associada a um único código de situação, que é o "14". Esse código representa uma categoria comum de situação dos alunos em suas respectivas turmas.
Comentários Associados:

Para algumas situações, existem comentários adicionais que fornecem contexto. Por exemplo:
Situação "14" está associada a comentários sobre "Retorno das aulas na escola para o presencial" e "Falta de condições financeiras para o transporte".
Situação "19" tem comentários como "Alfa N - 1N" e "Vide ocorrência", indicando reavaliações ou referências a outras ocorrências.
Essas informações podem ser úteis para entender melhor as razões por trás das situações dos alunos nas turmas e ajudar a identificar áreas onde intervenções ou suporte adicional podem ser necessários.
"""

# Comparing student situations with demographic data: gender and race
situation_gender = df.groupby(['IdSituacaoAlunoTurma', 'Sexo']).size().unstack().fillna(0)
situation_race = df.groupby(['IdSituacaoAlunoTurma', 'CorRaca']).size().unstack().fillna(0)

# Plotting the comparison between student situations and gender
plt.figure(figsize=(12, 6))
situation_gender.plot(kind='bar', stacked=True)
plt.title('Situações dos Alunos nas Turmas por Gênero')
plt.xlabel('ID da Situação do Aluno na Turma')
plt.ylabel('Número de Alunos')
plt.xticks(rotation=0)
plt.legend(title='Gênero')
plt.show()

# Plotting the comparison between student situations and race
plt.figure(figsize=(12, 6))
situation_race.plot(kind='bar', stacked=True)
plt.title('Situações dos Alunos nas Turmas por Cor/Raça')
plt.xlabel('ID da Situação do Aluno na Turma')
plt.ylabel('Número de Alunos')
plt.xticks(rotation=0)
plt.legend(title='Cor/Raça')
plt.show()

"""Comparação das Situações dos Alunos com Dados Demográficos
A análise das situações dos alunos nas turmas em relação aos dados demográficos de gênero e cor/raça revela o seguinte:

Situações por Gênero:

Para a situação mais comum (código "14"), há um equilíbrio na distribuição entre alunos do sexo masculino e feminino.
Para outras situações, como o código "19", a distribuição também parece relativamente equilibrada, indicando que as questões que afetam as situações dos alunos não são fortemente influenciadas pelo gênero.
Situações por Cor/Raça:

A maioria das situações (especialmente o código "14") está associada ao grupo racial predominante (código "B").
Isso reflete a distribuição geral de raça/cor no conjunto de dados, sem grandes desvios em termos de situação acadêmica.
"""

# Defina a consulta SQL para a view
query = 'SELECT * FROM magic_steps.vw_aluno'

# Execute a consulta e carregue os resultados em um DataFrame
df_aluno = pd.read_sql(query, engine)

# Mostre as primeiras linhas do DataFrame
print(df_aluno.head())